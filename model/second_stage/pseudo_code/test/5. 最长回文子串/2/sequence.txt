def longestPalindrome(self, s):
    n为字符串s长度
    if (长度小于2)
        output:  返回字符串
    else:
        初始化最长子串的长度max_len等于1
        初始化最长回文子串的左边界索引begin等于0
        初始化dp数组，长宽均等于字符串的长度，全部初始化为False。dp[i][j]表示s[i..j] 是否是回文串
        下标i等于0
        while(下标没有越界)
            dp中第一维下标和第二维下标均为i的元素是回文串
            下标加1
        定义L为度最长子串可能的长，初值为2，
        while(最长子串可能的长小于字符串长度加一)
            i等于0，记录子串左边界
            while(左边界是否小于字符串的长度)
                令子串右边界j等于子串可能的长度加左边界减1
                if (如果右边界越界)
                    break
                if (字符串左边界上的元素不等于右边界上的元素)
                    从左边界至右边界的子串不是回文串
                else:
                    if (右边界减去左边界小于3)
                        从左边界至右边界的子串是回文串
                    else:
                        左边界至右边界的子串是否是回文串取决于左边界加一至右边界减一的子串是否是回文串
                if (左边界至右边界的子串是回文串，且右边界减去左边界加一的值大于最长子串的长度)
                    最长子串的长度等于右边界减去左边界加一
                    最长子串的左边界索引等于i
                else:
                左边界向右移动一个单位
            最长子串可能的长自增1
        output:  计算从最长回文子串左边界开始max_len个长度的子串并返回
