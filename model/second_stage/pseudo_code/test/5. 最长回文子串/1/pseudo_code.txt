NSpace
0
1
2
1
2
2
2
2
2
3
3
4
4
3
3
2
2
3
3
4
4
5
4
4
3
2

GUID
None
cond4894
io4901
None
op4907
op4909
op4911
op4913
cond4916
op4935
cond4938
op4942
op4944
None
op1
op4951
cond4954
op4993
cond4996
op5013
cond5016
op5020
None
op3
op2
io5032

Str
def longestPalindrome(self, s):@
if (特判，当字符串s的长度为1或者0时)@
output:  返回字符串@
else:@
n为字符串s的长度@
初始化dp数组，长宽均等于字符串的长度，全部初始化为False。dp[i][j]表示s[i至j]是否为回文串。@
初始化最长回文子串的左边界索引start等于0，初始化最长长度max_len等于1@
i等于0，为字符串下标@
while(字符串下标没有越界)@
dp中所有单个字符组成的串都是回文串，更新dp@
if (若i小于字符串的长度减一且字符串下标为i的字符和其后一个字符相同)@
字符串s[i至i+1]是回文串@
最长回文子串左边界的索引等于i，最长长度等于2@
else:@
下标向右移动@
定义1为最长子串可能的长度，初值为3，@
while(最长子串可能的长度小于字符串长度加一)@
i等于0，记录子串左边界@
while(计算字符串长度加一减去可能的长度的结果，判断左边界是否小于该结果)@
令子串右边界r等于左边界加子串可能的长度减1@
if (字符串s左边界上的元素等于右边界上的元素并且s[左边界加一至右边界减一]是回文串)@
从左边界至右边界的子串也是回文串，并更新最长子串左边界等于i，和最长长度等于l@
else:@
左边界向左移动@
最长子串可能的长度增长1@
output:  计算从最长回文子串左边界开始max_len个长度的子串并返回@

Type
Function
If
Effect
Else
Effect
Effect
Effect
Effect
While
Effect
If
Effect
Effect
Else
Effect
Effect
While
Effect
While
Effect
If
Effect
Else
Effect
Effect
Effect
