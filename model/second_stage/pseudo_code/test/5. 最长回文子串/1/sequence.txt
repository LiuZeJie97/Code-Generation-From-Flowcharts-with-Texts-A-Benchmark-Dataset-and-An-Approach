def longestPalindrome(self, s):
    if (特判，当字符串s的长度为1或者0时)
        output:  返回字符串
    else:
        n为字符串s的长度
        初始化dp数组，长宽均等于字符串的长度，全部初始化为False。dp[i][j]表示s[i至j]是否为回文串。
        初始化最长回文子串的左边界索引start等于0，初始化最长长度max_len等于1
        i等于0，为字符串下标
        while(字符串下标没有越界)
            dp中所有单个字符组成的串都是回文串，更新dp
            if (若i小于字符串的长度减一且字符串下标为i的字符和其后一个字符相同)
                字符串s[i至i+1]是回文串
                最长回文子串左边界的索引等于i，最长长度等于2
            else:
            下标向右移动
        定义1为最长子串可能的长度，初值为3，
        while(最长子串可能的长度小于字符串长度加一)
            i等于0，记录子串左边界
            while(计算字符串长度加一减去可能的长度的结果，判断左边界是否小于该结果)
                令子串右边界r等于左边界加子串可能的长度减1
                if (字符串s左边界上的元素等于右边界上的元素并且s[左边界加一至右边界减一]是回文串)
                    从左边界至右边界的子串也是回文串，并更新最长子串左边界等于i，和最长长度等于l
                else:
                左边界向左移动
            最长子串可能的长度增长1
        output:  计算从最长回文子串左边界开始max_len个长度的子串并返回
